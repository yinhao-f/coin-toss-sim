import java.util.Arrays;
import java.util.Scanner;
import java.util.Stack;

public class Main {
    public static void genFlip(boolean[] flips, int index, int[] numOfEvents) {
        if (index == flips.length - 1) {
            flips[index] = !flips[index];
            // Record
            numOfEvents[countHTH(flips)]++;

            flips[index] = !flips[index];
            // Record
            numOfEvents[countHTH(flips)]++;

        } else {
            flips[index] = !flips[index];
            genFlip(flips, index + 1, numOfEvents);
            flips[index] = !flips[index];
            genFlip(flips, index + 1, numOfEvents);
        }
    }

    // Iterative replacement for recursion generated by DeepSeek
    public static void genFlip(boolean[] flips, int[] numOfEvents) {
        Stack<int[]> stack = new Stack<>();
        stack.push(new int[]{0, 0}); // {index, state}

        while (!stack.isEmpty()) {
            int[] current = stack.pop();
            int index = current[0];
            int state = current[1];

            if (index == flips.length - 1) {
                // Flip the last bit and record
                flips[index] = !flips[index];
                numOfEvents[countHTH(flips)]++;
                flips[index] = !flips[index];
                numOfEvents[countHTH(flips)]++;
            } else {
                if (state == 0) {
                    // First visit: flip the current bit and explore further
                    flips[index] = !flips[index];
                    stack.push(new int[]{index, 1}); // Mark as visited
                    stack.push(new int[]{index + 1, 0}); // Move to next index
                } else if (state == 1) {
                    // Second visit: unflip the current bit and explore further
                    flips[index] = !flips[index];
                    stack.push(new int[]{index, 2}); // Mark as visited
                    stack.push(new int[]{index + 1, 0}); // Move to next index
                }
                // No need to handle state == 2, as it means we're done with this index
            }
        }
    }

    public static int countHTH(boolean[] flips) {
        int sum = 0;
        for (int i = 2; i < flips.length; i++) {
            boolean HTH = flips[i] && !flips[i - 1] && flips[i - 2];
            if (HTH) {
                sum++;
            }
        }

        if (sum > 0) {
            System.out.println(Arrays.toString(flips) + " number of HTH: " + sum);
        }

        return sum;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Input number of flips: ");
        int n = sc.nextInt();
        int[] numOfEvents = new int[(n - 1) / 2 + 1];
        boolean[] flips = new boolean[n];

        genFlip(flips, numOfEvents); // Non-recursive
        // genFlip(flips, 0, numOfEvents); // Recursive

        double exp = 0;

        System.out.println("For n = " + n);

        for (int i = 1; i < numOfEvents.length; i++) {
            System.out.printf("Number of outcomes when X = %d: %d\n", i, numOfEvents[i]);
            exp += i * ((double) numOfEvents[i] / (1 << n));
        }

        System.out.println("E[X] = " + exp);
        
        double p = 0.5;
        double formula = (n - 2) * p * p * (1-p);
        System.out.println("Using formula (n-2)(1-p)p^2 when p = 0.5: " + formula);
    }
}